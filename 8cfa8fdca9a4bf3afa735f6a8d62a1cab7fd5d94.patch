From 8cfa8fdca9a4bf3afa735f6a8d62a1cab7fd5d94 Mon Sep 17 00:00:00 2001
From: Jeremy Gebben <jgebben@codeaurora.org>
Date: Fri, 8 Apr 2011 10:13:55 -0600
Subject: [PATCH] msm: kgsl: clean up barriers for ringbuffer manipulation

Remove barriers from kgsl_ringbuffer_submit() and GSL_GET_READPTR().
Testing shows that the wmb() in GSL_RB_WRITE() is necessary for
7x27.

Also, remove GSL_RB_UPDATE_WPTR_POLLING entirely since we've always
used the nop definition of this macro.

CRs-fixed: 286391
Change-Id: I54ad5bdae6d0edb51835a920368e009ba6d506d1
Signed-off-by: Jeremy Gebben <jgebben@codeaurora.org>
---
 drivers/gpu/msm/adreno_ringbuffer.c |   13 +++----------
 drivers/gpu/msm/adreno_ringbuffer.h |   15 +++------------
 2 files changed, 6 insertions(+), 22 deletions(-)

diff --git a/drivers/gpu/msm/adreno_ringbuffer.c b/drivers/gpu/msm/adreno_ringbuffer.c
index 9849e3e..0d8cd83 100644
--- a/drivers/gpu/msm/adreno_ringbuffer.c
+++ b/drivers/gpu/msm/adreno_ringbuffer.c
@@ -157,17 +157,10 @@ static void kgsl_ringbuffer_submit(struct kgsl_ringbuffer *rb)
 {
 	BUG_ON(rb->wptr == 0);
 
-	GSL_RB_UPDATE_WPTR_POLLING(rb);
-	/* Drain write buffer and data memory barrier */
-	dsb();
-	wmb();
-
-	/* Memory fence to ensure all data has posted.  On some systems,
-	* like 7x27, the register block is not allocated as strongly ordered
-	* memory.  Adding a memory fence ensures ordering during ringbuffer
-	* submits.*/
+	/*synchronize memory before informing the hardware of the
+	 *new commands.
+	 */
 	mb();
-	outer_sync();
 
 	kgsl_yamato_regwrite(rb->device, REG_CP_RB_WPTR, rb->wptr);
 
diff --git a/drivers/gpu/msm/adreno_ringbuffer.h b/drivers/gpu/msm/adreno_ringbuffer.h
index 6c39ee8..7b568c1 100644
--- a/drivers/gpu/msm/adreno_ringbuffer.h
+++ b/drivers/gpu/msm/adreno_ringbuffer.h
@@ -101,11 +101,11 @@ struct kgsl_ringbuffer {
 
 #define GSL_RB_WRITE(ring, gpuaddr, data) \
 	do { \
-		writel(data, ring); \
+		writel_relaxed(data, ring); \
+		wmb(); \
 		kgsl_cffdump_setmem(gpuaddr, data, 4); \
 		ring++; \
 		gpuaddr += sizeof(uint); \
-		wmb(); \
 	} while (0)
 
 /* timestamp */
@@ -130,8 +130,7 @@ struct kgsl_ringbuffer {
 #define GSL_RB_CNTL_NO_UPDATE 0x0 /* enable */
 #define GSL_RB_GET_READPTR(rb, data) \
 	do { \
-		*(data) = readl(&(rb)->memptrs->rptr); \
-		rmb(); \
+		*(data) = readl_relaxed(&(rb)->memptrs->rptr); \
 	} while (0)
 #else
 #define GSL_RB_CNTL_NO_UPDATE 0x1 /* disable */
@@ -141,15 +140,7 @@ struct kgsl_ringbuffer {
 	} while (0)
 #endif /* GSL_RB_USE_MEMRPTR */
 
-/* wptr polling */
-#ifdef GSL_RB_USE_WPTR_POLLING
-#define GSL_RB_CNTL_POLL_EN 0x1 /* enable */
-#define GSL_RB_UPDATE_WPTR_POLLING(rb) \
-	do { writel((rb)->wptr, &((rb)->memptrs->wptr_poll)); } while (0)
-#else
 #define GSL_RB_CNTL_POLL_EN 0x0 /* disable */
-#define GSL_RB_UPDATE_WPTR_POLLING(rb)
-#endif	/* GSL_RB_USE_WPTR_POLLING */
 
 int kgsl_ringbuffer_issueibcmds(struct kgsl_device_private *dev_priv,
 				struct kgsl_context *context,
-- 
1.7.5.4

