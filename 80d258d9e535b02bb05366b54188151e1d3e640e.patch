From 80d258d9e535b02bb05366b54188151e1d3e640e Mon Sep 17 00:00:00 2001
From: Naomi Luis <nluis@codeaurora.org>
Date: Mon, 12 Dec 2011 12:07:48 -0800
Subject: [PATCH] base: genlock: Add error messages for failure cases

Signed-off-by: Naomi Luis <nluis@codeaurora.org>
Change-Id: I833e480abfc11ce4aa00a5ae46144895429a0339
---
 drivers/base/genlock.c |   58 ++++++++++++++++++++++++++++++++++++-----------
 1 files changed, 44 insertions(+), 14 deletions(-)

diff --git a/drivers/base/genlock.c b/drivers/base/genlock.c
index 6fbc660..8fe67be 100644
--- a/drivers/base/genlock.c
+++ b/drivers/base/genlock.c
@@ -33,6 +33,9 @@
 #define _RDLOCK  GENLOCK_RDLOCK
 #define _WRLOCK GENLOCK_WRLOCK
 
+#define GENLOCK_LOG_ERR(fmt, args...) \
+pr_err("genlock: %s: " fmt, __func__, ##args)
+
 struct genlock {
 	struct list_head active;  /* List of handles holding lock */
 	spinlock_t lock;          /* Spinlock to protect the lock internals */
@@ -109,12 +112,16 @@ struct genlock *genlock_create_lock(struct genlock_handle *handle)
 {
 	struct genlock *lock;
 
-	if (handle->lock != NULL)
+	if (handle->lock != NULL) {
+		GENLOCK_LOG_ERR("Handle already has a lock attached\n");
 		return ERR_PTR(-EINVAL);
+	}
 
 	lock = kzalloc(sizeof(*lock), GFP_KERNEL);
-	if (lock == NULL)
+	if (lock == NULL) {
+		GENLOCK_LOG_ERR("Unable to allocate memory for a lock\n");
 		return ERR_PTR(-ENOMEM);
+	}
 
 	INIT_LIST_HEAD(&lock->active);
 	init_waitqueue_head(&lock->queue);
@@ -147,8 +154,10 @@ static int genlock_get_fd(struct genlock *lock)
 {
 	int ret;
 
-	if (lock->file == NULL)
+	if (!lock->file) {
+		GENLOCK_LOG_ERR("No file attached to the lock\n");
 		return -EINVAL;
+	}
 
 	ret = get_unused_fd_flags(0);
 	if (ret < 0)
@@ -170,12 +179,16 @@ struct genlock *genlock_attach_lock(struct genlock_handle *handle, int fd)
 	struct file *file;
 	struct genlock *lock;
 
-	if (handle->lock != NULL)
+	if (handle->lock != NULL) {
+		GENLOCK_LOG_ERR("Handle already has a lock attached\n");
 		return ERR_PTR(-EINVAL);
+	}
 
 	file = fget(fd);
-	if (file == NULL)
+	if (file == NULL) {
+		GENLOCK_LOG_ERR("Bad file descriptor\n");
 		return ERR_PTR(-EBADF);
+	}
 
 	/*
 	 * take a spinlock to avoid a race condition if the lock is
@@ -188,8 +201,10 @@ struct genlock *genlock_attach_lock(struct genlock_handle *handle, int fd)
 
 	fput(file);
 
-	if (lock == NULL)
+	if (lock == NULL) {
+		GENLOCK_LOG_ERR("File descriptor is invalid\n");
 		return ERR_PTR(-EINVAL);
+	}
 
 	handle->lock = lock;
 	kref_get(&lock->refcount);
@@ -233,13 +248,16 @@ static int _genlock_unlock(struct genlock *lock, struct genlock_handle *handle)
 
 	spin_lock_irqsave(&lock->lock, irqflags);
 
-	if (lock->state == _UNLOCKED)
+	if (lock->state == _UNLOCKED) {
+		GENLOCK_LOG_ERR("Trying to unlock an unlocked handle\n");
 		goto done;
+	}
 
 	/* Make sure this handle is an owner of the lock */
-	if (!handle_has_lock(lock, handle))
+	if (!handle_has_lock(lock, handle)) {
+		GENLOCK_LOG_ERR("handle does not have lock attached to it\n");
 		goto done;
-
+	}
 	/* If the handle holds no more references to the lock then
 	   release it (maybe) */
 
@@ -308,7 +326,8 @@ static int _genlock_lock(struct genlock *lock, struct genlock_handle *handle,
 		 * Otherwise the user tried to turn a read into a write, and we
 		 * don't allow that.
 		 */
-
+		GENLOCK_LOG_ERR("Trying to upgrade a read lock to a write"
+				"lock\n");
 		ret = -EINVAL;
 		goto done;
 	}
@@ -378,8 +397,10 @@ int genlock_lock(struct genlock_handle *handle, int op, int flags,
 	struct genlock *lock = handle->lock;
 	int ret = 0;
 
-	if (lock == NULL)
+	if (lock == NULL) {
+		GENLOCK_LOG_ERR("Handle does not have a lock attached\n");
 		return -EINVAL;
+	}
 
 	switch (op) {
 	case GENLOCK_UNLOCK:
@@ -390,6 +411,7 @@ int genlock_lock(struct genlock_handle *handle, int op, int flags,
 		ret = _genlock_lock(lock, handle, op, flags, timeout);
 		break;
 	default:
+		GENLOCK_LOG_ERR("Invalid lock operation\n");
 		ret = -EINVAL;
 		break;
 	}
@@ -411,8 +433,10 @@ int genlock_wait(struct genlock_handle *handle, uint32_t timeout)
 	int ret = 0;
 	unsigned int ticks = msecs_to_jiffies(timeout);
 
-	if (lock == NULL)
+	if (lock == NULL) {
+		GENLOCK_LOG_ERR("Handle does not have a lock attached\n");
 		return -EINVAL;
+	}
 
 	spin_lock_irqsave(&lock->lock, irqflags);
 
@@ -502,8 +526,10 @@ static int genlock_handle_release(struct inode *inodep, struct file *file)
 static struct genlock_handle *_genlock_get_handle(void)
 {
 	struct genlock_handle *handle = kzalloc(sizeof(*handle), GFP_KERNEL);
-	if (handle == NULL)
+	if (handle == NULL) {
+		GENLOCK_LOG_ERR("Unable to allocate memory for the handle\n");
 		return ERR_PTR(-ENOMEM);
+	}
 
 	return handle;
 }
@@ -574,8 +600,11 @@ static long genlock_dev_ioctl(struct file *filep, unsigned int cmd,
 		return 0;
 	}
 	case GENLOCK_IOC_EXPORT: {
-		if (handle->lock == NULL)
+		if (handle->lock == NULL) {
+			GENLOCK_LOG_ERR("Handle does not have a lock"
+					"attached\n");
 			return -EINVAL;
+		}
 
 		ret = genlock_get_fd(handle->lock);
 		if (ret < 0)
@@ -620,6 +649,7 @@ static long genlock_dev_ioctl(struct file *filep, unsigned int cmd,
 		return 0;
 	}
 	default:
+		GENLOCK_LOG_ERR("Invalid ioctl\n");
 		return -EINVAL;
 	}
 }
-- 
1.7.5.4

