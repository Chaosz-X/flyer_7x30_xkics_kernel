From 7f823919b82eb7ca3d3569bbf833eed7a2f0dc74 Mon Sep 17 00:00:00 2001
From: Jordan Crouse <jcrouse@codeaurora.org>
Date: Tue, 27 Dec 2011 16:28:45 +0100
Subject: [PATCH] msm: kgsl: Facilitate building without CONFIG_MSM_KGSL_MMU

Move most MMU related code to kgsl_mmu.c, and make that file
compile conditionally based on the CONFIG_MSM_KGSL_MMU setting.
Use static inlines where appropriate to make things more streamlined.

Change-Id: I8ff4ec2834b995a07e26bf8802d1d9bae162ff69
Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
---
 drivers/video/msm/gpu/kgsl_adreno205_hc/adreno.c   |    4 +-
 drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl.c     |   89 ++++-----------
 drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl.h     |    8 +-
 drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl_mmu.c |   48 ++++++--
 drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl_mmu.h |  119 +++++++++++++-------
 5 files changed, 141 insertions(+), 127 deletions(-)

diff --git a/drivers/video/msm/gpu/kgsl_adreno205_hc/adreno.c b/drivers/video/msm/gpu/kgsl_adreno205_hc/adreno.c
index f4de5b9..d87c735 100644
--- a/drivers/video/msm/gpu/kgsl_adreno205_hc/adreno.c
+++ b/drivers/video/msm/gpu/kgsl_adreno205_hc/adreno.c
@@ -795,8 +795,8 @@ static int kgsl_yamato_getproperty(struct kgsl_device *device,
 			memset(&devinfo, 0, sizeof(devinfo));
 			devinfo.device_id = device->id+1;
 			devinfo.chip_id = device->chip_id;
-			devinfo.mmu_enabled = kgsl_mmu_isenabled(&device->mmu);
-//			devinfo.gpu_id = adreno_get_rev(adreno_dev);
+			devinfo.mmu_enabled = kgsl_mmu_enabled();
+// FIXME		devinfo.gpu_id = adreno_get_rev(adreno_dev);
 			devinfo.gpu_id = 205;
 			devinfo.gmem_gpubaseaddr = yamato_device->gmemspace.
 					gpu_base;
diff --git a/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl.c b/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl.c
index c8b7221..d0767ee 100644
--- a/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl.c
+++ b/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl.c
@@ -294,19 +294,6 @@ static void kgsl_check_idle(struct kgsl_device *device)
 	mutex_unlock(&device->mutex);
 }
 
-static void kgsl_clean_cache_all(struct kgsl_process_private *private)
-{
-	struct kgsl_mem_entry *entry = NULL;
-
-	spin_lock(&private->mem_lock);
-	list_for_each_entry(entry, &private->mem_list, list) {
-		if (entry->memdesc.priv & KGSL_MEMFLAGS_CACHED)
-			kgsl_cache_range_op(&entry->memdesc,
-					    KGSL_CACHE_OP_CLEAN);
-	}
-	spin_unlock(&private->mem_lock);
-}
-
 struct kgsl_device *kgsl_get_device(int dev_idx)
 {
 	int i;
@@ -394,41 +381,6 @@ int kgsl_idle(struct kgsl_device *device, unsigned int timeout)
 }
 EXPORT_SYMBOL(kgsl_idle);
 
-int kgsl_setup_pt(struct kgsl_pagetable *pt)
-{
-	int i = 0;
-	int status = 0;
-
-	for (i = 0; i < KGSL_DEVICE_MAX; i++) {
-		struct kgsl_device *device = kgsl_driver.devp[i];
-		if (device) {
-			status = device->ftbl.device_setup_pt(device, pt);
-			if (status)
-				goto error_pt;
-		}
-	}
-	return status;
-error_pt:
-	while (i >= 0) {
-		struct kgsl_device *device = kgsl_driver.devp[i];
-		if (device)
-			device->ftbl.device_cleanup_pt(device, pt);
-		i--;
-	}
-	return status;
-}
-
-int kgsl_cleanup_pt(struct kgsl_pagetable *pt)
-{
-	int i;
-	for (i = 0; i < KGSL_DEVICE_MAX; i++) {
-		struct kgsl_device *device = kgsl_driver.devp[i];
-		if (device)
-			device->ftbl.device_cleanup_pt(device, pt);
-	}
-	return 0;
-}
-
 static int kgsl_suspend_device(struct kgsl_device *device, pm_message_t state)
 {
 	int status = -EINVAL;
@@ -649,11 +601,7 @@ int kgsl_resume_driver(struct platform_device *pdev)
 		kgsl_mem_entry_put(entry);
 	}
 
-#ifdef CONFIG_MSM_KGSL_MMU
-	if (private->pagetable != NULL)
-		kgsl_mmu_putpagetable(private->pagetable);
-#endif
-
+	kgsl_mmu_putpagetable(private->pagetable);
 	kfree(private);
 unlock:
 	mutex_unlock(&kgsl_driver.process_mutex);
@@ -791,7 +739,7 @@ static int kgsl_open(struct inode *inodep, struct file *filep)
 	mutex_unlock(&device->mutex);
 
 	KGSL_DRV_INFO(device, "Initialized %s: mmu=%s pagetable_count=%d\n",
-		device->name, kgsl_mmu_isenabled(&dev_priv->device->mmu) ? "on" : "off",
+		device->name, kgsl_mmu_enabled() ? "on" : "off",
 		KGSL_PAGETABLE_COUNT);
 
 	return result;
@@ -1237,7 +1185,7 @@ static long kgsl_ioctl_sharedmem_free(struct kgsl_device_private *dev_priv,
 	struct kgsl_mem_entry *entry = NULL;
 	struct vm_area_struct *vma;
 
-	if (!kgsl_mmu_isenabled(&dev_priv->device->mmu))
+	if (!kgsl_mmu_enabled())
 		return -ENODEV;
 
 	/* Make sure all pending freed memory is collected */
@@ -1273,6 +1221,8 @@ static long kgsl_ioctl_sharedmem_free(struct kgsl_device_private *dev_priv,
 	if (result != 0)
 		goto error_free_entry;
 
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+
 	result = remap_vmalloc_range(vma, (void *) entry->memdesc.hostptr, 0);
 	if (result) {
 		KGSL_CORE_ERR("remap_vmalloc_range failed: %d\n", result);
@@ -1315,7 +1265,7 @@ static int kgsl_get_phys_file(int fd, unsigned long *start, unsigned long *len,
 	if (!get_pmem_file(fd, start, vstart, len, filep))
 		return 0;
 
-	fget(fd);
+	fbfile = fget(fd);
 	if (fbfile == NULL) {
 		KGSL_CORE_ERR("fget_light failed\n");
 		return -1;
@@ -1508,11 +1458,13 @@ static long kgsl_ioctl_map_user_mem(struct kgsl_device_private *dev_priv,
 		break;
 
 	case KGSL_USER_MEM_TYPE_ADDR:
-#ifndef CONFIG_MSM_KGSL_MMU
-		KGSL_DRV_ERR(dev_priv->device,
-			"Cannot map paged memory with the MMU disabled\n");
-		break;
-#endif
+		if (!kgsl_mmu_enabled()) {
+			KGSL_DRV_ERR(dev_priv->device,
+				"Cannot map paged memory with the "
+				"MMU disabled\n");
+			break;
+		}
+
 		if (param->hostptr == 0)
 			break;
 
@@ -1522,11 +1474,13 @@ static long kgsl_ioctl_map_user_mem(struct kgsl_device_private *dev_priv,
 		break;
 
 	case KGSL_USER_MEM_TYPE_ASHMEM:
-#ifndef CONFIG_MSM_KGSL_MMU
-		KGSL_DRV_ERR(dev_priv->device,
-			"Cannot map paged memory with the MMU disabled\n");
-		break;
-#endif
+		if (!kgsl_mmu_enabled()) {
+			KGSL_DRV_ERR(dev_priv->device,
+				"Cannot map paged memory with the "
+				"MMU disabled\n");
+			break;
+		}
+
 		if (param->hostptr == 0)
 			break;
 
@@ -1583,9 +1537,6 @@ static long kgsl_ioctl_map_user_mem(struct kgsl_device_private *dev_priv,
 	struct kgsl_sharedmem_free *param = data;
 	struct kgsl_process_private *private = dev_priv->process_priv;
 
-	if (!kgsl_mmu_isenabled(&dev_priv->device->mmu))
-		return -ENODEV;
-
 	spin_lock(&private->mem_lock);
 	entry = kgsl_sharedmem_find(private, param->gpuaddr);
 	if (!entry) {
diff --git a/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl.h b/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl.h
index e23a614..d24906e 100644
--- a/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl.h
+++ b/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl.h
@@ -74,9 +74,13 @@
 #define KGSL_PAGETABLE_ENTRIES(_sz) (((_sz) >> PAGE_SHIFT) + \
 				     KGSL_PT_EXTRA_ENTRIES)
 
+#ifdef CONFIG_MSM_KGSL_MMU
 #define KGSL_PAGETABLE_SIZE \
 ALIGN(KGSL_PAGETABLE_ENTRIES(CONFIG_MSM_KGSL_PAGE_TABLE_SIZE) * \
 KGSL_PAGETABLE_ENTRY_SIZE, PAGE_SIZE)
+#else
+#define KGSL_PAGETABLE_SIZE 0
+#endif
 
 #ifdef CONFIG_KGSL_PER_PROCESS_PAGE_TABLE
 #define KGSL_PAGETABLE_COUNT (CONFIG_MSM_KGSL_PAGE_TABLE_COUNT)
@@ -199,10 +203,6 @@ static inline void kgsl_regwrite_isr(struct kgsl_device *device,
 
 int kgsl_check_timestamp(struct kgsl_device *device, unsigned int timestamp);
 
-int kgsl_setup_pt(struct kgsl_pagetable *);
-
-int kgsl_cleanup_pt(struct kgsl_pagetable *);
-
 int kgsl_register_ts_notifier(struct kgsl_device *device,
 			      struct notifier_block *nb);
 
diff --git a/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl_mmu.c b/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl_mmu.c
index 3006319..878ed59 100644
--- a/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl_mmu.c
+++ b/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl_mmu.c
@@ -338,6 +338,41 @@ int kgsl_ptpool_init(struct kgsl_ptpool *pool, int ptsize, int entries)
 
 /* pt_mutex needs to be held in this function */
 
+static int kgsl_setup_pt(struct kgsl_pagetable *pt)
+{
+	int i = 0;
+	int status = 0;
+
+	for (i = 0; i < KGSL_DEVICE_MAX; i++) {
+		struct kgsl_device *device = kgsl_driver.devp[i];
+		if (device) {
+			status = device->ftbl.device_setup_pt(device, pt);
+			if (status)
+				goto error_pt;
+		}
+	}
+	return status;
+error_pt:
+	while (i >= 0) {
+		struct kgsl_device *device = kgsl_driver.devp[i];
+		if (device)
+			device->ftbl.device_cleanup_pt(device, pt);
+		i--;
+	}
+	return status;
+}
+
+static int kgsl_cleanup_pt(struct kgsl_pagetable *pt)
+{
+	int i;
+	for (i = 0; i < KGSL_DEVICE_MAX; i++) {
+		struct kgsl_device *device = kgsl_driver.devp[i];
+		if (device)
+			device->ftbl.device_cleanup_pt(device, pt);
+	}
+	return 0;
+}
+
 static struct kgsl_pagetable *
 kgsl_get_pagetable(unsigned long name)
 {
@@ -771,14 +806,6 @@ int kgsl_mmu_init(struct kgsl_device *device)
 
 	mmu->device = device;
 
-#ifndef CONFIG_MSM_KGSL_MMU
-	mmu->config = 0x00000000;
-#endif
-
-	/* MMU not enabled */
-	if ((mmu->config & 0x1) == 0)
-		return 0;
-
 	/* make sure aligned to pagesize */
 	BUG_ON(mmu->mpu_base & (PAGE_SIZE - 1));
 	BUG_ON((mmu->mpu_base + mmu->mpu_range) & (PAGE_SIZE - 1));
@@ -877,10 +904,6 @@ int kgsl_mmu_start(struct kgsl_device *device)
 	return status;
 }
 
-
-
-#ifdef CONFIG_MSM_KGSL_MMU
-
 unsigned int kgsl_virtaddr_to_physaddr(void *virtaddr)
 {
 	unsigned int physaddr = 0;
@@ -1039,7 +1062,6 @@ unsigned int kgsl_virtaddr_to_physaddr(void *virtaddr)
 
 	return 0;
 }
-#endif /*CONFIG_MSM_KGSL_MMU*/
 
 int kgsl_mmu_map_global(struct kgsl_pagetable *pagetable,
 			struct kgsl_memdesc *memdesc, unsigned int protflags)
diff --git a/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl_mmu.h b/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl_mmu.h
index a4a4521..d4aa026 100644
--- a/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl_mmu.h
+++ b/drivers/video/msm/gpu/kgsl_adreno205_hc/kgsl_mmu.h
@@ -153,59 +153,73 @@ struct kgsl_ptpool {
 	int chunks;
 };
 
-int kgsl_mmu_init(struct kgsl_device *device);
+struct kgsl_pagetable *kgsl_mmu_getpagetable(unsigned long name);
 
-int kgsl_mmu_start(struct kgsl_device *device);
+#ifdef CONFIG_MSM_KGSL_MMU
 
+int kgsl_mmu_init(struct kgsl_device *device);
+int kgsl_mmu_start(struct kgsl_device *device);
 int kgsl_mmu_stop(struct kgsl_device *device);
 
 int kgsl_mmu_close(struct kgsl_device *device);
 
-struct kgsl_pagetable *kgsl_mmu_getpagetable(unsigned long name);
+int kgsl_mmu_setstate(struct kgsl_device *device,
+		     struct kgsl_pagetable *pagetable);
 
+int kgsl_mmu_map(struct kgsl_pagetable *pagetable,
+		struct kgsl_memdesc *memdesc,
+		unsigned int protflags);
+int kgsl_mmu_map_global(struct kgsl_pagetable *pagetable,
+		       struct kgsl_memdesc *memdesc, unsigned int protflags);
+int kgsl_mmu_unmap(struct kgsl_pagetable *pagetable,
+		   struct kgsl_memdesc *memdesc);
+void kgsl_ptpool_destroy(struct kgsl_ptpool *pool);
+int kgsl_ptpool_init(struct kgsl_ptpool *pool, int ptsize, int entries);
+void kgsl_mh_intrcallback(struct kgsl_device *device);
 void kgsl_mmu_putpagetable(struct kgsl_pagetable *pagetable);
+unsigned int kgsl_virtaddr_to_physaddr(void *virtaddr);
 
-int kgsl_mmu_setstate(struct kgsl_device *device,
-			struct kgsl_pagetable *pagetable);
-
-static inline unsigned int kgsl_pt_get_flags(struct kgsl_pagetable *pt,
-					     enum kgsl_deviceid id)
+static inline int kgsl_mmu_enabled(void)
 {
-	unsigned int result = 0;
-	spin_lock(&pt->lock);
-	if (pt->tlb_flags && (1<<id)) {
-		result = KGSL_MMUFLAGS_TLBFLUSH;
-		pt->tlb_flags &= ~(1<<id);
-	}
-	spin_unlock(&pt->lock);
-	return result;
+	return 1;
 }
 
-#ifdef CONFIG_MSM_KGSL_MMU
-int kgsl_mmu_map(struct kgsl_pagetable *pagetable,
-		 struct kgsl_memdesc *memdesc,
-		 unsigned int protflags);
+#else
 
-int kgsl_mmu_unmap(struct kgsl_pagetable *pagetable,
-		   struct kgsl_memdesc *memdesc);
+static inline int kgsl_mmu_enabled(void)
+{
+	return 0;
+}
 
-unsigned int kgsl_virtaddr_to_physaddr(void *virtaddr);
+static inline int kgsl_mmu_init(struct kgsl_device *device)
+{
+	return 0;
+}
 
-void kgsl_ptpool_destroy(struct kgsl_ptpool *pool);
+static inline int kgsl_mmu_start(struct kgsl_device *device)
+{
+	return 0;
+}
 
-int kgsl_ptpool_init(struct kgsl_ptpool *pool, int ptsize, int entries);
+static inline int kgsl_mmu_stop(struct kgsl_device *device)
+{
+	return 0;
+}
 
-static inline int
-kgsl_mmu_isenabled(struct kgsl_mmu *mmu)
+static inline int kgsl_mmu_close(struct kgsl_device *device)
 {
-	return ((mmu)->flags & KGSL_FLAGS_STARTED) ? 1 : 0;
+	return 0;
+}
+
+static inline int kgsl_mmu_setstate(struct kgsl_device *device,
+				   struct kgsl_pagetable *pagetable)
+{
+	return 0;
 }
 
-#else
 static inline int kgsl_mmu_map(struct kgsl_pagetable *pagetable,
 		 struct kgsl_memdesc *memdesc,
-		 unsigned int protflags,
-		 unsigned int flags)
+		 unsigned int protflags)
 {
 	memdesc->gpuaddr = memdesc->physaddr;
 	return 0;
@@ -213,9 +227,9 @@ static inline int kgsl_mmu_map(struct kgsl_pagetable *pagetable,
 
 static inline int kgsl_mmu_unmap(struct kgsl_pagetable *pagetable,
 				 struct kgsl_memdesc *memdesc)
-{ return 0; }
-
-static inline int kgsl_mmu_isenabled(struct kgsl_mmu *mmu) { return 0; }
+{
+	return 0;
+}
 
 static inline int kgsl_ptpool_init(struct kgsl_ptpool *pool, int ptsize,
 				    int entries)
@@ -223,16 +237,43 @@ static inline int kgsl_ptpool_init(struct kgsl_ptpool *pool, int ptsize,
 	return 0;
 }
 
-static inline void kgsl_ptpool_free(struct kgsl_ptpool *pool) { }
+static inline int kgsl_mmu_map_global(struct kgsl_pagetable *pagetable,
+       struct kgsl_memdesc *memdesc, unsigned int protflags)
+{
+	/* gpuaddr is the same that gets passed in */
+	return 0;
+}
+
+static inline void kgsl_ptpool_destroy(struct kgsl_ptpool *pool) { }
+
+static inline void kgsl_mh_intrcallback(struct kgsl_device *device) { }
 
+static inline void kgsl_mmu_putpagetable(struct kgsl_pagetable *pagetable) { }
+
+static inline unsigned int kgsl_virtaddr_to_physaddr(void *virtaddr)
+{
+	return 0;
+}
 #endif
 
-int kgsl_mmu_map_global(struct kgsl_pagetable *pagetable,
-			struct kgsl_memdesc *memdesc, unsigned int protflags);
+static inline unsigned int kgsl_pt_get_flags(struct kgsl_pagetable *pt,
+					    enum kgsl_deviceid id)
+{
+	unsigned int result = 0;
+
+	if (pt == NULL)
+		return 0;
+
+	spin_lock(&pt->lock);
+	if (pt->tlb_flags && (1<<id)) {
+		result = KGSL_MMUFLAGS_TLBFLUSH;
+		pt->tlb_flags &= ~(1<<id);
+	}
+	spin_unlock(&pt->lock);
+	return result;
+}
 
 int kgsl_mmu_querystats(struct kgsl_pagetable *pagetable,
 			struct kgsl_ptstats *stats);
 
-void kgsl_mh_intrcallback(struct kgsl_device *device);
-
 #endif /* __GSL_MMU_H */
-- 
1.7.5.4

